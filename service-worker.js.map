{"version":3,"file":"service-worker.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AE9GA;AACA;AACA;AACA;AACA","sources":["webpack://learning_and_relax/./src/background/service-worker.ts","webpack://learning_and_relax/webpack/before-startup","webpack://learning_and_relax/webpack/startup","webpack://learning_and_relax/webpack/after-startup"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconsole.log(\"Service Worker loaded.\");\nconst MAIN_TIMER_ALARM = 'mainTimer';\nconst WORK_REST_ALARM = 'workRestAlarm';\n// --- Utility Functions ---\nfunction getRandomWorkInterval() {\n    return Math.floor(Math.random() * (5 - 3 + 1) + 3);\n}\nfunction sendMessageToActiveTab(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [tab] = yield chrome.tabs.query({ active: true, lastFocusedWindow: true });\n        if (tab && tab.id) {\n            try {\n                yield chrome.tabs.sendMessage(tab.id, message);\n            }\n            catch (e) {\n                console.error(\"Could not send message to content script:\", e);\n            }\n        }\n    });\n}\n// --- Alarm Management ---\nchrome.alarms.onAlarm.addListener((alarm) => __awaiter(void 0, void 0, void 0, function* () {\n    const storage = yield chrome.storage.local.get();\n    if (!storage.isRunning)\n        return;\n    if (alarm.name === WORK_REST_ALARM) {\n        if (storage.isResting) {\n            yield chrome.storage.local.set({ isResting: false });\n            yield sendMessageToActiveTab({ command: 'hide_overlay' });\n            chrome.notifications.create({ type: 'basic', iconUrl: 'icon128.svg', title: '休息结束', message: '继续保持专注！' });\n            chrome.alarms.create(WORK_REST_ALARM, { delayInMinutes: getRandomWorkInterval() });\n        }\n        else {\n            yield chrome.storage.local.set({ isResting: true });\n            yield sendMessageToActiveTab({ command: 'show_overlay' });\n            chrome.notifications.create({ type: 'basic', iconUrl: 'icon128.svg', title: '该休息啦！', message: '放松15秒，看看远处。' });\n            chrome.alarms.create(WORK_REST_ALARM, { delayInMinutes: 15 / 60 });\n        }\n    }\n    else if (alarm.name === MAIN_TIMER_ALARM) {\n        // This alarm now primarily checks if the total time has expired.\n        const elapsedSeconds = Math.floor((Date.now() - storage.startTime) / 1000);\n        if (elapsedSeconds >= storage.totalDuration * 60) {\n            stopTimer();\n            chrome.notifications.create({ type: 'basic', iconUrl: 'icon128.svg', title: '工作结束', message: '恭喜你，完成了本次专注工作！' });\n        }\n    }\n}));\n// --- Timer Control Functions ---\nfunction stopTimer() {\n    chrome.alarms.clearAll();\n    chrome.storage.local.set({ isRunning: false }); // No need to reset other values\n    sendMessageToActiveTab({ command: 'hide_overlay' });\n    chrome.action.setBadgeText({ text: '' });\n    console.log(\"Timer stopped and all alarms cleared.\");\n}\n// --- Message Listener ---\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.command === 'start') {\n        const totalMinutes = message.totalMinutes || 60;\n        chrome.storage.local.set({\n            isRunning: true,\n            isResting: false,\n            totalDuration: totalMinutes,\n            startTime: Date.now(), // Store the precise start time\n        }, () => {\n            chrome.alarms.create(MAIN_TIMER_ALARM, { periodInMinutes: 1 });\n            chrome.alarms.create(WORK_REST_ALARM, { delayInMinutes: getRandomWorkInterval() });\n            chrome.action.setBadgeText({ text: 'ON' });\n            chrome.action.setBadgeBackgroundColor({ color: '#4688F1' });\n            sendResponse({ success: true });\n        });\n        return true;\n    }\n    else if (message.command === 'stop') {\n        stopTimer();\n        sendResponse({ success: true });\n    }\n    else if (message.command === 'get_status') {\n        chrome.storage.local.get().then(storage => {\n            if (storage.isRunning) {\n                const elapsedSeconds = Math.floor((Date.now() - storage.startTime) / 1000);\n                const timeLeft = (storage.totalDuration * 60) - elapsedSeconds;\n                sendResponse(Object.assign(Object.assign({}, storage), { timeLeft }));\n            }\n            else {\n                sendResponse(storage);\n            }\n        });\n        return true;\n    }\n});\n// Initialize state on installation\nchrome.runtime.onInstalled.addListener(() => {\n    chrome.storage.local.set({\n        isRunning: false,\n        isResting: false,\n        totalDuration: 60,\n        startTime: 0,\n    });\n    chrome.action.setBadgeText({ text: '' });\n});\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/background/service-worker.ts\"]();\n",""],"names":[],"sourceRoot":""}